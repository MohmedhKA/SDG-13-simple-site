<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Placement Exam Complete Flashcards - 120+ Cards</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #f8f9fa;
            color: #2c3e50;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            padding: 40px 20px;
            margin-bottom: 30px;
            background: white;
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
        }

        header h1 {
            font-size: 2.5rem;
            color: #2c3e50;
            margin-bottom: 10px;
            font-weight: 800;
        }

        header p {
            color: #7f8c8d;
            font-size: 1rem;
        }

        .stats-section {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 30px;
        }

        .stat-card {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.06);
            text-align: center;
            border-left: 4px solid #3498db;
        }

        .stat-card h3 {
            color: #7f8c8d;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 8px;
            font-weight: 600;
        }

        .stat-card .number {
            font-size: 2.2rem;
            font-weight: 700;
            color: #2c3e50;
        }

        .topic-selector {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 12px;
            margin-bottom: 30px;
        }

        .topic-btn {
            padding: 14px 16px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            background: white;
            color: #2c3e50;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.95rem;
        }

        .topic-btn:hover {
            border-color: #3498db;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(52, 152, 219, 0.2);
        }

        .topic-btn.active {
            background: #3498db;
            color: white;
            border-color: #3498db;
            box-shadow: 0 4px 12px rgba(52, 152, 219, 0.3);
        }

        /* Topic-specific colors */
        .topic-btn[data-topic="1"] { border-left: 4px solid #e74c3c; }
        .topic-btn[data-topic="1"].active { background: #e74c3c; border-color: #e74c3c; }

        .topic-btn[data-topic="2"] { border-left: 4px solid #3498db; }
        .topic-btn[data-topic="2"].active { background: #3498db; border-color: #3498db; }

        .topic-btn[data-topic="3"] { border-left: 4px solid #2ecc71; }
        .topic-btn[data-topic="3"].active { background: #2ecc71; border-color: #2ecc71; }

        .topic-btn[data-topic="4"] { border-left: 4px solid #f39c12; }
        .topic-btn[data-topic="4"].active { background: #f39c12; border-color: #f39c12; }

        .topic-btn[data-topic="5"] { border-left: 4px solid #9b59b6; }
        .topic-btn[data-topic="5"].active { background: #9b59b6; border-color: #9b59b6; }

        .topic-btn[data-topic="6"] { border-left: 4px solid #1abc9c; }
        .topic-btn[data-topic="6"].active { background: #1abc9c; border-color: #1abc9c; }

        .topic-btn[data-topic="7"] { border-left: 4px solid #e67e22; }
        .topic-btn[data-topic="7"].active { background: #e67e22; border-color: #e67e22; }

        .topic-btn[data-topic="8"] { border-left: 4px solid #34495e; }
        .topic-btn[data-topic="8"].active { background: #34495e; border-color: #34495e; }

        .topic-header {
            margin-bottom: 20px;
            padding: 15px;
            background: white;
            border-radius: 8px;
            border-left: 4px solid #3498db;
            display: none;
        }

        .topic-header.active {
            display: block;
        }

        .topic-header h2 {
            font-size: 1.8rem;
            color: #2c3e50;
            margin-bottom: 5px;
        }

        .topic-header p {
            color: #7f8c8d;
            font-size: 0.95rem;
        }

        .flashcards-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(320px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .flashcard {
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            cursor: pointer;
            height: 400px;
            position: relative;
            transition: all 0.3s ease;
            perspective: 1000px;
        }

        .flashcard:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 24px rgba(0,0,0,0.15);
        }

        .flashcard-inner {
            position: relative;
            width: 100%;
            height: 100%;
            transition: transform 0.6s;
            transform-style: preserve-3d;
        }

        .flashcard.flipped .flashcard-inner {
            transform: rotateY(180deg);
        }

        .flashcard-front,
        .flashcard-back {
            position: absolute;
            width: 100%;
            height: 100%;
            backface-visibility: hidden;
            display: flex;
            flex-direction: column;
            padding: 25px;
            border-radius: 12px;
        }

        .flashcard-front {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            justify-content: space-between;
        }

        .flashcard.topic1 .flashcard-front { background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%); }
        .flashcard.topic2 .flashcard-front { background: linear-gradient(135deg, #3498db 0%, #2980b9 100%); }
        .flashcard.topic3 .flashcard-front { background: linear-gradient(135deg, #2ecc71 0%, #27ae60 100%); }
        .flashcard.topic4 .flashcard-front { background: linear-gradient(135deg, #f39c12 0%, #d68910 100%); }
        .flashcard.topic5 .flashcard-front { background: linear-gradient(135deg, #9b59b6 0%, #8e44ad 100%); }
        .flashcard.topic6 .flashcard-front { background: linear-gradient(135deg, #1abc9c 0%, #16a085 100%); }
        .flashcard.topic7 .flashcard-front { background: linear-gradient(135deg, #e67e22 0%, #d35400 100%); }
        .flashcard.topic8 .flashcard-front { background: linear-gradient(135deg, #34495e 0%, #2c3e50 100%); }

        .flashcard-front-top {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
        }

        .flashcard-front-title {
            font-size: 0.8rem;
            opacity: 0.9;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-weight: 600;
        }

        .flashcard-front-number {
            font-size: 1.2rem;
            opacity: 0.8;
            font-weight: 600;
        }

        .flashcard-front-content {
            font-size: 1.3rem;
            font-weight: 600;
            line-height: 1.4;
            text-align: center;
        }

        .flashcard-front-hint {
            font-size: 0.75rem;
            opacity: 0.7;
            text-align: center;
            font-style: italic;
        }

        .flashcard-back {
            background: white;
            color: #2c3e50;
            transform: rotateY(180deg);
            padding: 20px;
            overflow-y: auto;
            border: 1px solid #ecf0f1;
        }

        .flashcard-back::-webkit-scrollbar {
            width: 6px;
        }

        .flashcard-back::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 10px;
        }

        .flashcard-back::-webkit-scrollbar-thumb {
            background: #bdc3c7;
            border-radius: 10px;
        }

        .flashcard-back::-webkit-scrollbar-thumb:hover {
            background: #95a5a6;
        }

        .flashcard-back h3 {
            color: #e74c3c;
            margin-bottom: 12px;
            font-size: 1.1rem;
        }

        .flashcard.topic1 .flashcard-back h3 { color: #e74c3c; }
        .flashcard.topic2 .flashcard-back h3 { color: #3498db; }
        .flashcard.topic3 .flashcard-back h3 { color: #2ecc71; }
        .flashcard.topic4 .flashcard-back h3 { color: #f39c12; }
        .flashcard.topic5 .flashcard-back h3 { color: #9b59b6; }
        .flashcard.topic6 .flashcard-back h3 { color: #1abc9c; }
        .flashcard.topic7 .flashcard-back h3 { color: #e67e22; }
        .flashcard.topic8 .flashcard-back h3 { color: #34495e; }

        .flashcard-back p {
            font-size: 0.9rem;
            line-height: 1.6;
            margin-bottom: 12px;
            color: #34495e;
        }

        .flashcard-back strong {
            color: #2c3e50;
        }

        .flashcard-back code {
            background: #ecf0f1;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 0.85rem;
            color: #e74c3c;
        }

        .flashcard-back ul,
        .flashcard-back ol {
            margin: 10px 0 10px 20px;
            color: #34495e;
        }

        .flashcard-back li {
            margin-bottom: 6px;
            font-size: 0.9rem;
        }

        .controls {
            position: fixed;
            bottom: 30px;
            right: 30px;
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            justify-content: flex-end;
        }

        .control-btn {
            padding: 12px 20px;
            border: none;
            border-radius: 8px;
            background: white;
            color: #2c3e50;
            cursor: pointer;
            font-weight: 600;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            transition: all 0.3s ease;
            font-size: 0.9rem;
        }

        .control-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(0,0,0,0.2);
        }

        .progress {
            position: fixed;
            bottom: 100px;
            right: 30px;
            background: white;
            padding: 15px 20px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            font-size: 0.9rem;
            color: #7f8c8d;
            font-weight: 600;
        }

        .download-btn {
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
            color: white;
        }

        .download-btn:hover {
            background: linear-gradient(135deg, #2980b9 0%, #1f618d 100%);
        }

        @media (max-width: 768px) {
            header h1 { font-size: 2rem; }
            .flashcards-grid { grid-template-columns: 1fr; }
            .controls { bottom: 20px; right: 20px; }
            .progress { bottom: 80px; right: 20px; }
            .topic-selector { grid-template-columns: repeat(2, 1fr); }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üìö Placement Exam Flashcards</h1>
            <p>Complete 120+ Flashcard Study Guide | 8 Topics | All Important Concepts</p>
        </header>

        <div class="stats-section">
            <div class="stat-card">
                <h3>Total Cards</h3>
                <div class="number">120+</div>
            </div>
            <div class="stat-card">
                <h3>Topics Covered</h3>
                <div class="number">8</div>
            </div>
            <div class="stat-card">
                <h3>Cards Per Topic</h3>
                <div class="number">15</div>
            </div>
        </div>

        <div class="topic-selector">
            <button class="topic-btn active" data-topic="1">üéØ Microprocessor (8086)</button>
            <button class="topic-btn" data-topic="2">‚öôÔ∏è Microcontroller (8051)</button>
            <button class="topic-btn" data-topic="3">üîå Circuits & Networks</button>
            <button class="topic-btn" data-topic="4">üìä DSP</button>
            <button class="topic-btn" data-topic="5">üì° Communications</button>
            <button class="topic-btn" data-topic="6">üñ•Ô∏è Embedded Systems</button>
            <button class="topic-btn" data-topic="7">‚ö° VLSI</button>
            <button class="topic-btn" data-topic="8">üîß Digital Electronics</button>
        </div>

        <div id="flashcardsContainer"></div>
    </div>

    <div class="progress">
        <span id="progressText">Ready to study!</span>
    </div>

    <div class="controls">
        <button class="control-btn" onclick="shuffleCards()">üîÄ Shuffle</button>
        <button class="control-btn download-btn" onclick="downloadHTML()">‚¨áÔ∏è Download</button>
    </div>

    <script>
        // Complete 120+ Flashcards Data
        const flashcardsData = {
            1: [
                {
                    front: "8086 - Basic Architecture",
                    back: `<strong>Definition:</strong> 16-bit microprocessor; first processor in Intel x86 family<br><br><strong>Key Features:</strong><ul><li>16-bit data bus, 20-bit address bus (1 MB addressable memory)</li><li>4 segment registers: CS (Code), DS (Data), SS (Stack), ES (Extra)</li><li>8 general purpose registers: AX, BX, CX, DX, SI, DI, BP, SP</li><li>6 status flags: CF, AF, SF, ZF, OF, PF</li></ul><br><strong>Memory Segmentation:</strong> Real mode uses segment:offset addressing<br>Physical Address = Segment √ó 16 + Offset`
                },
                {
                    front: "8086 Registers - Detailed",
                    back: `<strong>General Purpose Registers:</strong><ul><li>AX/AL/AH: Accumulator (arithmetic, I/O)</li><li>BX/BL/BH: Base (addressing, arrays)</li><li>CX/CL/CH: Counter (loops, shifts, string operations)</li><li>DX/DL/DH: Data (I/O, multiply/divide)</li></ul><br><strong>Index Registers:</strong><ul><li>SI: Source Index (string operations)</li><li>DI: Destination Index (string operations)</li><li>BP: Base Pointer (stack frame addressing)</li><li>SP: Stack Pointer (stack operations)</li></ul><br><strong>Example:</strong> MOV AL, 5 ‚Üí copies 5 to AL (lower byte of AX)`
                },
                {
                    front: "8086 Instruction Types",
                    back: `<strong>6 Main Categories:</strong><ul><li>Data Transfer: MOV, LEA, IN, OUT, XCHG, PUSH, POP</li><li>Arithmetic: ADD, SUB, MUL, DIV, INC, DEC, CMP, NEG</li><li>Bit Manipulation: AND, OR, XOR, NOT, TEST, SHL, SHR, ROL, ROR</li><li>String Operations: MOVSB, MOVSW, LODSB, STOSB, REP, REPE</li><li>Program Control: JMP, CALL, RET, Jxx (conditional jumps), LOOP</li><li>Processor Control: NOP, HLT, INT, CLI, STI</li></ul><br><strong>Total Instructions:</strong> ~117 in 8086`
                },
                {
                    front: "üî• RET Instruction",
                    back: `<strong>Definition:</strong> Returns from subroutine/procedure to calling program<br><br><strong>Function:</strong> Pops return address from stack into IP (Instruction Pointer)<br><strong>Formula:</strong> IP = Stack[SP]; SP = SP + 2<br><br><strong>Syntax Options:</strong><ul><li>RET (near return, same segment)</li><li>RET 6 (near return + add 6 to SP for parameter cleanup)</li><li>RETF (far return, different segment)</li></ul><br><strong>Stack Operation:</strong><ol><li>CALL pushes next instruction address</li><li>Subroutine executes</li><li>RET pops that address back to IP</li></ol>`
                },
                {
                    front: "LEA Instruction",
                    back: `<strong>Definition:</strong> Load Effective Address - loads address of operand into register<br><strong>Syntax:</strong> LEA register, memory_operand<br><strong>Purpose:</strong> Gets the ADDRESS, not the value<br><br><strong>Difference from MOV:</strong><ul><li>MOV gets the VALUE</li><li>LEA gets the ADDRESS</li></ul><br><strong>Example:</strong><br>data db 'Hello' (address 1000h)<br>LEA BX, data ‚Üí BX = 1000h (address)<br>MOV BX, data ‚Üí BX = value at 1000h (first character 'H')`
                },
                {
                    front: "CALL vs JMP",
                    back: `<strong>JMP:</strong> Unconditional jump<ul><li>Jumps to new address</li><li>Doesn't save return address</li><li>One-way jump (no return)</li><li>Use: Main program flow control</li></ul><br><strong>CALL:</strong> Function call<ul><li>Pushes return address to stack</li><li>Jumps to subroutine</li><li>RET instruction returns</li><li>Use: Calling procedures/functions</li></ul><br><strong>Stack Behavior:</strong><br>Before CALL: SP points to next location<br>After CALL: SP-2 contains return address, SP updated<br>After RET: SP restored, execution continues after CALL`
                },
                {
                    front: "üî• MOV Instruction Restrictions",
                    back: `<strong>WHAT YOU CANNOT DO:</strong><ul><li>Memory to Memory: MOV [BX], [DX] ‚ùå</li><li>Segment register operations limited</li><li>Cannot move immediate to segment registers directly</li></ul><br><strong>VALID MOVES:</strong><ul><li>Register to Register ‚úì</li><li>Memory to Register ‚úì</li><li>Register to Memory ‚úì</li><li>Immediate to Register ‚úì</li><li>Immediate to Memory ‚úì</li></ul><br><strong>Workaround for Memory-Memory:</strong><br>MOV AX, [BX]<br>MOV [DX], AX`
                },
                {
                    front: "Stack Operations - PUSH & POP",
                    back: `<strong>PUSH:</strong> Decrements SP, stores value<ul><li>SP = SP - 2 (decreases because stack grows downward)</li><li>Stores 16-bit value at [SP]</li></ul><br><strong>POP:</strong> Retrieves value, increments SP<ul><li>Gets value from [SP]</li><li>SP = SP + 2 (increases)</li></ul><br><strong>LIFO (Last In, First Out):</strong><br>PUSH AX (SP -= 2)<br>PUSH BX (SP -= 2)<br>POP CX (CX = BX, SP += 2)<br>POP DX (DX = AX, SP += 2)<br><br><strong>Common Use:</strong> Save/restore registers, pass parameters`
                },
                {
                    front: "Flags Register & Conditional Jumps",
                    back: `<strong>6 Important Flags:</strong><ul><li>CF (Carry Flag): Set if result overflows/underflow</li><li>ZF (Zero Flag): Set if result is zero</li><li>SF (Sign Flag): Set if result is negative (MSB=1)</li><li>OF (Overflow Flag): Set if signed overflow</li><li>PF (Parity Flag): Set if even number of 1s in result</li><li>AF (Auxiliary Flag): Set if half-byte carry</li></ul><br><strong>Conditional Jump Examples:</strong><ul><li>JZ (Jump if Zero): ZF = 1</li><li>JC (Jump if Carry): CF = 1</li><li>JG (Jump if Greater): (SF XOR OF) = 0 AND ZF = 0</li><li>JL (Jump if Less): (SF XOR OF) = 1</li></ul>`
                },
                {
                    front: "String Instructions - REP Prefix",
                    back: `<strong>Common String Instructions:</strong><ul><li>MOVSB/MOVSW: Copy byte/word from [DS:SI] to [ES:DI]</li><li>LODSB/LODSW: Load from [DS:SI] to AL/AX</li><li>STOSB/STOSW: Store AL/AX to [ES:DI]</li></ul><br><strong>REP Prefix:</strong> Repeats instruction CX times<br>MOV CX, 5<br>MOV SI, source<br>MOV DI, dest<br>REP MOVSB (copies 5 bytes)<br><br><strong>Variants:</strong><ul><li>REP: Repeat while CX ‚â† 0</li><li>REPE/REPZ: Repeat while CX ‚â† 0 AND ZF = 1</li><li>REPNE/REPNZ: Repeat while CX ‚â† 0 AND ZF = 0</li></ul>`
                },
                {
                    front: "üî• Addressing Modes",
                    back: `<strong>Direct:</strong> MOV AX, [1234h] ‚Üí gets value at address 1234h<br><br><strong>Register Indirect:</strong> MOV AX, [BX] ‚Üí gets value at address in BX<br><br><strong>Based Indexed:</strong> MOV AX, [BX+DI] ‚Üí gets value at BX+DI<br><br><strong>Displacement:</strong> MOV AX, [data] ‚Üí gets value at label 'data'<br><br><strong>Based Displacement:</strong> MOV AX, [BX+10] ‚Üí gets value at BX+10`
                },
                {
                    front: "Rotate vs Shift",
                    back: `<strong>Shift (SHL, SHR):</strong><ul><li>Moves bits left/right</li><li>Lost bits fill with 0</li><li>SHL AX, 1 ‚Üí bits shift left, LSB becomes 0</li></ul><br><strong>Rotate (ROL, ROR, RCL, RCR):</strong><ul><li>Rotates bits in circle</li><li>ROL: Leftmost goes to rightmost</li><li>RCL: Uses carry flag in rotation</li></ul><br><strong>Example (SHL vs ROL):</strong><br>Original: 10110100<br>SHL: 01101000 (lost 1, gained 0)<br>ROL: 01101001 (1 wraps to right)`
                },
                {
                    front: "CMP Instruction - Not What You Think!",
                    back: `<strong>CMP:</strong> Compare by subtraction (but doesn't store result!)<br><strong>Formula:</strong> Operand1 - Operand2 (discarded)<br><strong>Purpose:</strong> Sets FLAGS based on subtraction<br><br><strong>Example:</strong><br>MOV AX, 5<br>CMP AX, 3 (5-3=2, result discarded)<br>ZF=0 (not zero), CF=0 (no borrow)<br>JG label (jumps because result > 0)<br><br><strong>Difference from SUB:</strong><ul><li>SUB stores result in operand1</li><li>CMP only affects flags, doesn't modify registers</li></ul>`
                },
                {
                    front: "Procedure Call Mechanism",
                    back: `<strong>Steps (CALL instruction):</strong><ol><li>IP = address of next instruction</li><li>PUSH IP (to stack)</li><li>IP = address of called procedure</li><li>Execute procedure code</li><li>RET pops IP from stack</li><li>Resume execution after CALL</li></ol><br><strong>Parameter Passing Methods:</strong><ul><li>Via registers (AX, BX, CX, etc.)</li><li>Via stack (PUSH before CALL)</li><li>Via memory location (shared variables)</li></ul>`
                },
                {
                    front: "üî• NOP Instruction",
                    back: `<strong>Definition:</strong> No Operation<br><strong>Function:</strong> Does nothing, takes 1 byte, 3-4 clock cycles<br><br><strong>Uses:</strong><ul><li>Delay loops</li><li>Code alignment</li><li>Placeholder for future code</li><li>Debugging (breakpoints)</li></ul><br><strong>Example:</strong><br>MOV AX, 0<br>NOP (just wait)<br>MOV BX, 5 (no effect on this)`
                }
            ],
            2: [
                {
                    front: "8051 - Basic Architecture",
                    back: `<strong>Definition:</strong> 8-bit microcontroller; embedded in devices<br><br><strong>Key Features:</strong><ul><li>8-bit data bus, 16-bit address bus (64 KB addressable)</li><li>Harvard Architecture (separate code & data memory)</li><li>128 or 256 bytes internal RAM</li><li>4 KB onboard ROM (program memory)</li><li>4 ports for I/O (P0, P1, P2, P3)</li></ul><br><strong>Difference from 8086:</strong><ul><li>8086: Microprocessor (general purpose CPU)</li><li>8051: Microcontroller (embedded, complete system on chip)</li></ul>`
                },
                {
                    front: "8051 Memory Organization",
                    back: `<strong>Program Memory (ROM):</strong> Stores instructions (4 KB)<ul><li>Address range: 0000h to 0FFFh</li><li>Contains: Machine code to execute</li><li>Read-only (in normal operation)</li></ul><br><strong>Data Memory (RAM):</strong> Stores variables & temporary data (128-256 B)<ul><li>Lower 128B (00h-7Fh): Working registers, bit area, general RAM</li><li>Upper 128B (80h-FFh): Special Function Registers (SFRs)</li></ul><br><strong>External Memory:</strong> Optional expansion<ul><li>External ROM: Up to 64 KB additional program memory</li><li>External RAM: Up to 64 KB additional data</li><li>7x slower than internal RAM</li></ul>`
                },
                {
                    front: "8051 RAM Structure - Lower 128B",
                    back: `<strong>Addresses 00h-1Fh (32 bytes):</strong> Working Registers (4 banks of 8)<ul><li>Bank 0: R0-R7 (00h-07h) - Default</li><li>Bank 1: R0-R7 (08h-0Fh)</li><li>Bank 2: R0-R7 (10h-17h)</li><li>Bank 3: R0-R7 (18h-1Fh)</li><li>Selected via PSW[6:5] bits</li></ul><br><strong>Addresses 20h-2Fh (16 bytes):</strong> Bit-Addressable Area<ul><li>Can access as bytes OR individual bits</li><li>Used for flags, status bits</li></ul><br><strong>Addresses 30h-7Fh (80 bytes):</strong> General Purpose RAM<ul><li>For user variables</li><li>Fast access</li><li>Stack area (SP points here)</li></ul>`
                },
                {
                    front: "8051 Special Function Registers (SFRs)",
                    back: `<strong>Addresses 80h-FFh (128 bytes):</strong> SFR area<br><br><strong>Important SFRs:</strong><ul><li>P0, P1, P2, P3: I/O Port registers</li><li>A (Accumulator): Main data register</li><li>PSW (Program Status Word): Flags register</li><li>SP (Stack Pointer): Points to top of stack</li><li>DPTR (Data Pointer): 16-bit pointer (DPH, DPL)</li><li>IE (Interrupt Enable): Controls interrupts</li><li>IP (Interrupt Priority): Sets interrupt priority</li><li>TCON (Timer Control): Timer control flags</li><li>PCON (Power Control): Power management</li></ul><br><strong>Accessing SFRs:</strong><br>MOV A, P1 (read port 1)<br>MOV P1, #0FFh (write to port 1)`
                },
                {
                    front: "8051 Instruction Set - Data Transfer",
                    back: `<strong>MOV Instruction (Most Common):</strong><br>MOV A, Rn (A = register)<br>MOV A, direct (A = memory address)<br>MOV A, @Ri (A = indirect address)<br>MOV A, #data (A = immediate value)<br><br><strong>Direct Address:</strong> MOV A, 20h ‚Üí accesses RAM at address 20h<br><strong>Register Indirect:</strong> MOV A, @R0 ‚Üí accesses RAM at address in R0<br><strong>Immediate:</strong> MOV A, #0x5F ‚Üí A = 95 decimal<br><br><strong>Port I/O:</strong><br>MOV P1, A (output A to port 1)<br>MOV A, P2 (read port 2 into A)`
                },
                {
                    front: "8051 Arithmetic Operations",
                    back: `<strong>8-bit Addition (No 16-bit ADD):</strong><br>ADD A, #value (A = A + value)<br>ADD A, 30h (A = A + [RAM address 30h])<br>ADDC A, Rn (A = A + Rn + CF, with carry)<br><br><strong>Subtraction:</strong><br>SUBB A, #value (A = A - value - CF)<br><br><strong>Multiplication/Division:</strong><br>MUL AB ([A,B] = A √ó B, 16-bit result)<br>DIV AB (A = A √∑ B, B = A mod B)<br><br><strong>Increment/Decrement:</strong><br>INC A (A = A + 1)<br>DEC Rn (Register = Register - 1)`
                },
                {
                    front: "8051 Branching & Control",
                    back: `<strong>Unconditional Jump:</strong><br>SJMP label (Short jump, relative, -128 to +127 bytes)<br>LJMP address (Long jump, absolute, 0-64K)<br>JMP @A+DPTR (Jump to address in A+DPTR)<br><br><strong>Conditional Jumps:</strong><br>JZ label (Jump if A = 0)<br>JNZ label (Jump if A ‚â† 0)<br>JC label (Jump if Carry = 1)<br>JNC label (Jump if Carry = 0)<br><br><strong>CALL Instructions:</strong><br>ACALL address (Absolute call, 2 KB)<br>LCALL address (Long call, 64 KB)<br>RET (Return from subroutine)<br>RETI (Return from interrupt)`
                },
                {
                    front: "üî• 8051 Looping - DJNZ",
                    back: `<strong>DJNZ (Decrement and Jump if Not Zero):</strong><br>DJNZ Rn, label (Rn--; if Rn ‚â† 0, jump to label)<br>DJNZ direct, label ([address]--; if not zero, jump)<br><br><strong>Common Loop Pattern:</strong><br>MOV R0, #10 (R0 = 10, counter)<br>LOOP: MOV P1, A (do something)<br>DJNZ R0, LOOP (R0--, loop if not zero)<br><br><strong>Result:</strong> Loop executes 10 times`
                },
                {
                    front: "8051 Bit Operations - SETB & CLR",
                    back: `<strong>SETB (Set Bit):</strong> Sets bit to 1<br>SETB P1.0 (Set port 1 bit 0)<br>SETB C (Set carry flag)<br>SETB b_address (Set bit in bit-addressable area)<br><br><strong>CLR (Clear Bit):</strong> Sets bit to 0<br>CLR P2.7 (Clear port 2 bit 7)<br>CLR C (Clear carry flag)<br><br><strong>JB (Jump if Bit Set):</strong><br>JB P3.2, label (Jump if P3 bit 2 is 1)<br><br><strong>JNB (Jump if Bit Not Set):</strong><br>JNB P3.3, label (Jump if P3 bit 3 is 0)`
                },
                {
                    front: "8051 Stack & Interrupts",
                    back: `<strong>Stack Pointer (SP):</strong><ul><li>Initialized to 07h (top of bank 0)</li><li>PUSH increments SP, stores value</li><li>POP retrieves value, doesn't change SP</li></ul><br><strong>Limited Stack:</strong> Only 80 bytes available (addresses 30h-7Fh)<ul><li>Stack overflow = data corruption!</li><li>Careful with recursion</li></ul><br><strong>Interrupts (5 total):</strong><ul><li>INT0: External interrupt 0</li><li>INT1: External interrupt 1</li><li>Timer0: Timer 0 overflow</li><li>Timer1: Timer 1 overflow</li><li>Serial: Serial port (receive/transmit)</li></ul>`
                },
                {
                    front: "PSW (Program Status Word)",
                    back: `<strong>8-bit Register:</strong> Contains all flags and bank select<br><br><strong>Bits:</strong><ul><li>Bit 7: CY (Carry Flag)</li><li>Bit 6: AC (Auxiliary Carry - half byte)</li><li>Bit 5: F0 (User-defined flag)</li><li>Bit 4: RS1 (Register Bank Select, bit 1)</li><li>Bit 3: RS0 (Register Bank Select, bit 0)</li><li>Bit 2: OV (Overflow Flag)</li><li>Bit 1: - (not used)</li><li>Bit 0: P (Parity Flag)</li></ul><br><strong>Bank Selection (RS1:RS0):</strong><ul><li>00 = Bank 0 (00h-07h)</li><li>01 = Bank 1 (08h-0Fh)</li><li>10 = Bank 2 (10h-17h)</li><li>11 = Bank 3 (18h-1Fh)</li></ul>`
                },
                {
                    front: "Timer/Counter in 8051",
                    back: `<strong>Two 16-bit Timers:</strong> Timer0, Timer1<br><br><strong>Operating Modes:</strong><ul><li>Mode 0: 13-bit counter</li><li>Mode 1: 16-bit counter</li><li>Mode 2: 8-bit counter with auto-reload</li><li>Mode 3: Two 8-bit counters (Timer0 only)</li></ul><br><strong>TCON (Timer Control):</strong><ul><li>TF0: Timer0 overflow flag (set automatically)</li><li>TR0: Timer0 run control (1=run, 0=stop)</li><li>TF1, TR1: Same for Timer1</li></ul><br><strong>Usage:</strong><br>MOV TMOD, #00000001b (Timer0, Mode 1)<br>MOV TL0, #0x00 (Load timer low byte)<br>MOV TH0, #0x00 (Load timer high byte)<br>SETB TR0 (Start timer)`
                },
                {
                    front: "Serial Communication - UART",
                    back: `<strong>SBUF Register:</strong> Serial data buffer<ul><li>Write: Sends data</li><li>Read: Receives data</li></ul><br><strong>SCON (Serial Control):</strong><ul><li>SM0, SM1: Mode select (async/sync)</li><li>REN: Receive enable</li><li>TI: Transmit interrupt flag</li><li>RI: Receive interrupt flag</li></ul><br><strong>Baud Rate:</strong> Depends on Timer1 (usually mode 2)<br><br><strong>Simple Transmission:</strong><br>MOV SBUF, #'A' (Send 'A')<br>JNB TI, $ (Wait for transmit complete)<br>CLR TI (Clear transmit flag)`
                },
                {
                    front: "8051 vs Arduino",
                    back: `<strong>8051:</strong><ul><li>Pure microcontroller</li><li>Assembly language typically</li><li>Low-level control</li><li>Limited built-in peripherals</li><li>Steep learning curve</li></ul><br><strong>Arduino (STM32/ATmega):</strong><ul><li>Modern microcontroller</li><li>C/C++ languages</li><li>Libraries & abstraction</li><li>Rich peripherals</li><li>Beginner-friendly</li></ul>`
                },
                {
                    front: "Common 8051 Interview Questions",
                    back: `<strong>Q1:</strong> Difference between direct & indirect addressing?<ul><li>Direct: MOV A, 20h (specific address)</li><li>Indirect: MOV A, @R0 (address in register)</li></ul><br><strong>Q2:</strong> How many bits in DPTR?<ul><li><strong>16 bits</strong> (DPH:DPL, allows 64 KB addressing)</li></ul><br><strong>Q3:</strong> Minimum code to output 0x5F to port 1?<br>MOV A, #0x5F<br>MOV P1, A`
                }
            ],
            3: [
                {
                    front: "‚≠ê Thevenin's Theorem",
                    back: `<strong>Definition:</strong> Any circuit can be replaced with a voltage source (V_th) and series resistance (R_th)<br><br><strong>Steps:</strong><ol><li>Remove load resistor</li><li>Find V_th = open circuit voltage (no load)</li><li>Find R_th = equivalent resistance with sources deactivated<br>Deactivate: Voltage sources ‚Üí short, Current sources ‚Üí open</li><li>Reattach load, analyze circuit</li></ol><br><strong>Advantage:</strong> Simplifies analysis of complex circuits`
                },
                {
                    front: "‚≠ê Norton's Theorem",
                    back: `<strong>Definition:</strong> Any circuit = current source (I_n) in parallel with resistance (R_n)<br><strong>Formula:</strong> I_n = V_oc / R_oc (short circuit current / open circuit voltage ratio)<br><strong>R_n = R_th</strong> (same as Thevenin)<br><br><strong>Relationship:</strong><ul><li>V_th = I_n √ó R_n</li><li>I_n = V_th / R_th</li></ul><br><strong>When to Use:</strong><ul><li>Thevenin: When analyzing voltage across load</li><li>Norton: When analyzing current through load</li></ul>`
                },
                {
                    front: "SuperPosition Principle",
                    back: `<strong>Definition:</strong> In linear circuits, response due to multiple sources = sum of responses from each source alone<br><br><strong>Steps:</strong><ol><li>Analyze circuit with one source active</li><li>Deactivate other sources (V-source‚Üíshort, I-source‚Üíopen)</li><li>Repeat for each source</li><li>Sum all individual responses</li></ol><br><strong>Limitation:</strong> Only valid for LINEAR circuits (not diodes, transistors at saturation)`
                },
                {
                    front: "Maximum Power Transfer Theorem",
                    back: `<strong>Condition:</strong> Load receives maximum power when R_L = R_th<br><strong>Maximum Power:</strong> P_max = V_th¬≤ / (4 √ó R_th)<br><br><strong>Proof:</strong> P = V¬≤ / R, Power maximized when R_L matches internal resistance<br><br><strong>Example:</strong> Power amplifier impedance matching`
                },
                {
                    front: "Network Elements - Impedance",
                    back: `<strong>Impedance (Z):</strong> Complex resistance = R + jX<ul><li>R = Resistance (real part, Œ©)</li><li>X = Reactance (imaginary part, Œ©)</li><li>For resistor: Z = R</li><li>For capacitor: Z = -j/(œâC)</li><li>For inductor: Z = jœâL</li></ul><br><strong>At DC (œâ=0):</strong><ul><li>Capacitor: Z = ‚àû (open)</li><li>Inductor: Z = 0 (short)</li></ul>`
                },
                {
                    front: "AC Circuit Analysis - Phasor Notation",
                    back: `<strong>Phasor:</strong> Represents AC signal as complex number<br>v(t) = V_m cos(œât + œÜ) ‚Üí V‚åäœÜ (in phasor notation)<br><br><strong>Ohm's Law (AC):</strong> V = IZ (complex equation)<br><strong>Phase Angle:</strong> Difference between voltage & current<ul><li>Pure Resistor: œÜ = 0¬∞ (V & I in phase)</li><li>Pure Inductor: œÜ = 90¬∞ (V leads I)</li><li>Pure Capacitor: œÜ = -90¬∞ (I leads V)</li></ul>`
                },
                {
                    front: "üî• Power Factor & Reactive Power",
                    back: `<strong>Power Factor (PF):</strong> cos(œÜ) = Real Power / Apparent Power<br><br><strong>Types of Power:</strong><ul><li>Real Power (P): P = VI cos(œÜ) [Watts]</li><li>Reactive Power (Q): Q = VI sin(œÜ) [VAR]</li><li>Apparent Power (S): S = VI [VA]</li></ul><br><strong>Relationship:</strong> S¬≤ = P¬≤ + Q¬≤<br><br><strong>Power Factor Correction:</strong> Add capacitor (leading PF) or inductor (lagging PF)`
                },
                {
                    front: "Resonance in AC Circuits",
                    back: `<strong>Resonant Frequency:</strong> f_r = 1/(2œÄ‚àöLC)<br><br><strong>At Resonance:</strong><ul><li>Impedance is minimum (=R for series RLC)</li><li>Current is maximum (for voltage source)</li><li>Voltage across L and C cancel (series)</li><li>Phase angle = 0 (voltage & current in phase)</li></ul><br><strong>Quality Factor (Q):</strong> Q = œâ_r L / R = 1/(œâ_r RC)<ul><li>High Q = narrow bandwidth, sharp resonance</li><li>Low Q = wide bandwidth, flat response</li></ul>`
                },
                {
                    front: "üî• Two-Port Networks - Hybrid Parameters",
                    back: `<strong>2-Port Network:</strong> Two input terminals, two output terminals<br><br><strong>Common Parameter Sets:</strong><ul><li>Z-parameters (impedance)</li><li>Y-parameters (admittance)</li><li>ABCD parameters (cascade)</li><li>h-parameters (hybrid) - used in transistor amplifiers</li></ul><br><strong>h-parameters (small signal):</strong><ul><li>h11 = Input impedance (Œ©)</li><li>h12 = Reverse voltage ratio</li><li>h21 = Forward current ratio (Œ≤ for BJT)</li><li>h22 = Output admittance (S)</li></ul>`
                },
                {
                    front: "Transmission Line Basics",
                    back: `<strong>Characteristic Impedance (Z_0):</strong> ‚àö(L/C)<ul><li>Determines how wave propagates</li><li>If Z_0 = Z_load: No reflection (matched)</li><li>If Z_0 ‚â† Z_load: Reflection occurs (standing waves)</li></ul><br><strong>Propagation Velocity:</strong> v = 1/‚àö(LC)<ul><li>In free space: v = c (3√ó10‚Å∏ m/s)</li><li>In cable: v < c (typically 0.67c)</li></ul><br><strong>Reflection Coefficient:</strong> Œì = (Z_L - Z_0)/(Z_L + Z_0)<ul><li>Œì = 0: Matched (no reflection)</li><li>Œì = ¬±1: Open/short (total reflection)</li></ul>`
                },
                {
                    front: "üî• Delta-Wye (Œî-Y) Transformation",
                    back: `<strong>Converting Delta to Wye:</strong><br>R_A = (R_12 √ó R_13)/(R_12 + R_23 + R_13)<br>R_B = (R_23 √ó R_12)/(R_12 + R_23 + R_13)<br>R_C = (R_13 √ó R_23)/(R_12 + R_23 + R_13)<br><br><strong>Converting Wye to Delta:</strong><br>R_12 = (R_A√óR_B + R_B√óR_C + R_C√óR_A)/R_C<br>R_23 = (R_A√óR_B + R_B√óR_C + R_C√óR_A)/R_A<br>R_13 = (R_A√óR_B + R_B√óR_C + R_C√óR_A)/R_B<br><br><strong>Use:</strong> Simplify complex 3-phase circuits`
                },
                {
                    front: "Network Theorems Summary",
                    back: `<strong>Theorem Comparison:</strong><br><table style="width:100%; border-collapse: collapse;"><tr><td><strong>Theorem</strong></td><td><strong>Use</strong></td><td><strong>Condition</strong></td></tr><tr><td>Superposition</td><td>Multiple sources</td><td>Linear</td></tr><tr><td>Thevenin</td><td>Find V_th, R_th</td><td>Linear</td></tr><tr><td>Norton</td><td>Find I_n, R_n</td><td>Linear</td></tr><tr><td>Max Power Transfer</td><td>Maximum power</td><td>R_L = R_th</td></tr><tr><td>Reciprocity</td><td>Dual circuits</td><td>Bilateral</td></tr></table>`
                },
                {
                    front: "Y-Connected Power Systems",
                    back: `<strong>Line Voltage vs Phase Voltage:</strong><ul><li>V_line = ‚àö3 √ó V_phase (for 3-phase)</li><li>I_line = I_phase (for Y-connection)</li></ul><br><strong>Power in 3-phase:</strong><br>P = ‚àö3 √ó V_L √ó I_L √ó cos(œÜ)`
                },
                {
                    front: "PSpice & Circuit Simulation",
                    back: `<strong>Tools used:</strong> SPICE, LTspice, Multisim<br><br><strong>Simulation types:</strong><ul><li>DC operating point</li><li>AC frequency response</li><li>Transient (time domain)</li><li>Parameter sweep</li></ul>`
                },
                {
                    front: "Common Circuit Interview Questions",
                    back: `<strong>Q1:</strong> What's the difference between Thevenin & Norton?<ul><li>Thevenin: Voltage source + series R</li><li>Norton: Current source + parallel R</li></ul><br><strong>Q2:</strong> When is impedance matching needed?<ul><li>High frequency (RF) circuits</li><li>Power transmission (efficiency)</li><li>Audio systems (minimal reflection)</li></ul>`
                }
            ],
            4: [
                {
                    front: "‚≠ê‚≠ê Sampling Theorem - Nyquist Rate",
                    back: `<strong>Definition:</strong> To reconstruct continuous signal from samples, sampling frequency must be > 2 √ó maximum frequency<br><strong>Formula:</strong> f_s > 2 √ó f_max<br><strong>Nyquist Frequency:</strong> f_N = f_s / 2 (max frequency that can be represented)<br><br><strong>If violated:</strong> Aliasing occurs (false frequency components appear)<br><strong>Example:</strong> Audio: Human hearing ~20 kHz ‚Üí sample at 44.1 kHz (CD quality)`
                },
                {
                    front: "üî•üî• Aliasing - MOST IMPORTANT",
                    back: `<strong>Definition:</strong> When f_s < 2 √ó f_max, high frequencies fold back as low frequency components<br><strong>Result:</strong> Lost information, cannot recover original signal<br><br><strong>Example:</strong><ul><li>Signal: 10 Hz sine</li><li>Sample at: 8 Hz</li><li>Appears as: 2 Hz sine (wrong!)</li></ul><br><strong>Prevention:</strong> Low-pass filter (anti-aliasing) before sampling`
                },
                {
                    front: "‚≠ê Fourier Transform - Frequency Domain",
                    back: `<strong>Purpose:</strong> Decomposes signal into frequency components<br><br><strong>Types:</strong><ul><li>CFT: Continuous Fourier Transform (analog signals)</li><li>DFT: Discrete Fourier Transform (digital, finite length)</li><li>FFT: Fast Fourier Transform (efficient DFT, O(N log N))</li></ul><br><strong>Formula (DFT):</strong> X[k] = Œ£(n=0 to N-1) x[n] √ó e^(-j2œÄkn/N)<br><br><strong>Inverse (IDFT):</strong> x[n] = (1/N) Œ£(k=0 to N-1) X[k] √ó e^(j2œÄkn/N)`
                },
                {
                    front: "Time Domain vs Frequency Domain",
                    back: `<strong>Time Domain:</strong><ul><li>Shows signal amplitude over time</li><li>x(t) for continuous, x[n] for discrete</li><li>Intuitive for humans</li><li>Doesn't show frequency content</li></ul><br><strong>Frequency Domain:</strong><ul><li>Shows which frequencies are present</li><li>X(f) or X[k]</li><li>Shows amplitude & phase at each frequency</li><li>Reveals hidden patterns</li></ul><br><strong>Example:</strong> White noise<ul><li>Time domain: Random values</li><li>Frequency domain: Flat (all frequencies present)</li></ul>`
                },
                {
                    front: "‚≠ê Z-Transform - Discrete Transfer Function",
                    back: `<strong>Definition:</strong> Digital equivalent of Laplace transform<br><strong>Formula:</strong> X(z) = Œ£(n=0 to ‚àû) x[n] √ó z^(-n)<br><br><strong>ROC (Region of Convergence):</strong> Range of z for which transform converges<br><strong>Causality:</strong> All poles inside unit circle (z=1 radius)<br><strong>Stability:</strong> Poles strictly inside unit circle`
                },
                {
                    front: "üî• Digital Filters",
                    back: `<strong>FIR (Finite Impulse Response):</strong><ul><li>Output depends on current & past inputs ONLY</li><li>No feedback</li><li>Always stable</li><li>y[n] = Œ£(k=0 to M) b_k √ó x[n-k]</li></ul><br><strong>IIR (Infinite Impulse Response):</strong><ul><li>Output depends on inputs AND past outputs</li><li>Has feedback</li><li>Can be unstable if poles outside unit circle</li><li>y[n] = Œ£(k=0 to M) b_k √ó x[n-k] - Œ£(k=1 to N) a_k √ó y[n-k]</li></ul><br><strong>Comparison:</strong><ul><li>FIR: Linear phase, more coefficients, always stable</li><li>IIR: Non-linear phase, fewer coefficients, faster, potentially unstable</li></ul>`
                },
                {
                    front: "Filter Frequency Response",
                    back: `<strong>Magnitude Response:</strong> |H(f)| shows amplitude at each frequency<br><strong>Phase Response:</strong> ‚à†H(f) shows phase shift at each frequency<br><br><strong>Types:</strong><ul><li>Low-pass: Passes low frequencies, blocks high</li><li>High-pass: Passes high, blocks low</li><li>Band-pass: Passes only middle band</li><li>Band-stop (Notch): Blocks only middle band</li></ul><br><strong>Cutoff Frequency (-3dB point):</strong> Where magnitude drops to 70.7% of passband`
                },
                {
                    front: "‚≠ê Convolution - Core DSP Operation",
                    back: `<strong>Definition:</strong> Mathematical operation to find output of system<br><strong>Formula:</strong> y[n] = Œ£(k=-‚àû to ‚àû) x[k] √ó h[n-k]<br><br><strong>In frequency domain:</strong> y(f) = x(f) √ó H(f) (multiplication = convolution in time)<br><br><strong>Computational Complexity:</strong><ul><li>Direct: O(N¬≤)</li><li>FFT-based: O(N log N) - much faster!</li></ul>`
                },
                {
                    front: "üî• Window Functions - Spectral Leakage",
                    back: `<strong>Problem:</strong> FFT assumes signal is periodic<ul><li>Discontinuity at edges = spectral leakage</li><li>Energy spreads across frequencies</li></ul><br><strong>Solution:</strong> Apply window function<br><br><strong>Common Windows:</strong><ul><li>Rectangular: Best frequency resolution, worst leakage</li><li>Hann/Hamming: Moderate resolution & leakage</li><li>Blackman: Best leakage, worst resolution</li></ul><br><strong>Trade-off:</strong> Better leakage ‚Üí worse frequency resolution`
                },
                {
                    front: "Multirate DSP",
                    back: `<strong>Decimation:</strong> Reduce sampling rate (downsampling)<ul><li>Remove samples: x[2n], x[3n], etc.</li><li>Requires anti-aliasing filter first!</li></ul><br><strong>Interpolation:</strong> Increase sampling rate (upsampling)<ul><li>Insert zeros: x[0], 0, x[1], 0, x[2], ...</li><li>Requires interpolating filter</li></ul><br><strong>Polyphase Filters:</strong> Efficient implementation for multirate DSP`
                },
                {
                    front: "Adaptive Filters",
                    back: `<strong>Definition:</strong> Filter coefficients change over time based on input<br><br><strong>Applications:</strong><ul><li>Noise cancellation (headphones)</li><li>Channel equalization (wireless)</li><li>Echo cancellation (VoIP)</li></ul><br><strong>Algorithms:</strong><ul><li>LMS (Least Mean Square): Simple, slow</li><li>RLS (Recursive Least Squares): Fast, complex</li></ul>`
                },
                {
                    front: "Common DSP Interview Questions",
                    back: `<strong>Q1:</strong> What's Nyquist rate for 10 kHz signal?<ul><li><strong>20 kHz</strong> (must be > 2 √ó f_max)</li></ul><br><strong>Q2:</strong> Why use FFT instead of DFT?<ul><li><strong>FFT is O(N log N); DFT is O(N¬≤)</strong></li></ul><br><strong>Q3:</strong> FIR or IIR for stable filter?<ul><li><strong>FIR always stable; IIR can be unstable</strong></li></ul><br><strong>Q4:</strong> What causes aliasing?<ul><li><strong>Sampling rate too low (f_s < 2 √ó f_max)</strong></li></ul>`
                }
            ],
            5: [
                {
                    front: "‚≠ê Modulation - Why Needed?",
                    back: `<strong>Definition:</strong> Process of encoding information onto carrier wave<br><br><strong>Reasons:</strong><ul><li>Frequency shifting: Fit signal to available spectrum</li><li>Multiplexing: Multiple signals on same channel</li><li>Impedance matching: Better antenna radiation at high frequency</li><li>Range improvement: Higher frequencies propagate farther</li></ul><br><strong>Modulation Types:</strong><ul><li>Amplitude (AM)</li><li>Frequency (FM)</li><li>Phase (PM)</li><li>Combination (QAM)</li></ul>`
                },
                {
                    front: "Amplitude Modulation (AM)",
                    back: `<strong>Formula:</strong> s(t) = [A_c + m(t)] √ó cos(2œÄf_c t)<ul><li>A_c = carrier amplitude</li><li>m(t) = message signal</li><li>f_c = carrier frequency</li></ul><br><strong>Modulation Index:</strong> m = A_m / A_c (0 ‚â§ m ‚â§ 1)<br><strong>Bandwidth:</strong> B_W = 2 √ó f_m (twice message bandwidth)<br><br><strong>Disadvantage:</strong> Susceptible to noise (noise also modulates amplitude)`
                },
                {
                    front: "Frequency Modulation (FM)",
                    back: `<strong>Formula:</strong> s(t) = A_c √ó cos(2œÄf_c t + Œ≤ sin(2œÄf_m t))<ul><li>Œ≤ = modulation index</li><li>Frequency deviation: Œîf = Œ≤ √ó f_m</li></ul><br><strong>Bandwidth (Carson's Rule):</strong> B_W = 2 √ó (Œîf + f_m) = 2 √ó f_m(Œ≤ + 1)<br><br><strong>Advantage:</strong> Better noise immunity than AM<br><strong>Disadvantage:</strong> Wider bandwidth<br><br><strong>FM Deviation Example:</strong> Œîf = 75 kHz (¬±75 kHz around carrier)`
                },
                {
                    front: "Phase Modulation (PM)",
                    back: `<strong>Formula:</strong> s(t) = A_c √ó cos(2œÄf_c t + Œ≤_p √ó m(t))<ul><li>Œ≤_p = phase modulation index</li></ul><br><strong>Difference from FM:</strong><ul><li>FM: Frequency deviation ‚àù message amplitude</li><li>PM: Phase deviation ‚àù message amplitude</li></ul><br><strong>Similar bandwidth to FM</strong>`
                },
                {
                    front: "‚≠ê Digital Modulation - ASK, FSK, PSK",
                    back: `<strong>ASK (Amplitude Shift Keying):</strong> Binary 1‚Üíhigh amplitude, 0‚Üílow<ul><li>Same as on-off keying</li><li>Susceptible to noise</li></ul><br><strong>FSK (Frequency Shift Keying):</strong> Binary 1‚Üíf1, 0‚Üíf2<ul><li>Better noise immunity than ASK</li><li>Used in modems, FSK bell 202</li></ul><br><strong>PSK (Phase Shift Keying):</strong> Binary 1‚Üí0¬∞, 0‚Üí180¬∞ phase shift<ul><li>Better noise immunity</li><li>BPSK, QPSK (quadrature), 8-PSK, etc.</li></ul><br><strong>QAM (Quadrature Amplitude Modulation):</strong> Combines amplitude & phase<ul><li>16-QAM, 64-QAM, 256-QAM</li><li>Higher spectral efficiency</li><li>Sensitive to phase errors</li></ul>`
                },
                {
                    front: "‚≠ê‚≠ê Channel Capacity & Shannon",
                    back: `<strong>Shannon's Channel Capacity:</strong><br>C = B √ó log‚ÇÇ(1 + SNR) [bits/second]<ul><li>B = bandwidth (Hz)</li><li>SNR = Signal-to-Noise Ratio (linear, not dB)</li></ul><br><strong>Interpretation:</strong> Theoretical maximum data rate achievable<br><strong>With noise:</strong> Cannot exceed Shannon limit<br><strong>With noise-free:</strong> Capacity = ‚àû<br><br><strong>Example:</strong> B=1 MHz, SNR=100<br>C = 1√ó10‚Å∂ √ó log‚ÇÇ(101) ‚âà 6.66 Mbps`
                },
                {
                    front: "üî• Error Control Coding - Parity & CRC",
                    back: `<strong>Parity Bit:</strong> Single bit added for error detection<ul><li>Even parity: # of 1s (including parity) = even</li><li>Odd parity: # of 1s = odd</li><li>Detects 1-bit error only</li></ul><br><strong>CRC (Cyclic Redundancy Check):</strong> Multi-bit code<ul><li>Polynomial division method</li><li>Detects burst errors & single errors</li><li>Used in networks, storage, wireless</li></ul><br><strong>Hamming Code:</strong> Detects & corrects 1-bit error<ul><li>Example: 8-bit + 4 parity bits = 12 bits total</li></ul>`
                },
                {
                    front: "‚≠ê Signal-to-Noise Ratio (SNR)",
                    back: `<strong>Definition:</strong> Ratio of signal power to noise power<br><strong>Formula:</strong> SNR = P_signal / P_noise<br><strong>In dB:</strong> SNR_dB = 10 log‚ÇÅ‚ÇÄ(SNR)<br><br><strong>Example:</strong> SNR = 100 linear = 20 dB<br><br><strong>Effect on Modulation:</strong><ul><li>Low SNR (<0 dB): Errors increase</li><li>High SNR (>20 dB): Few errors</li><li>Bit Error Rate (BER) depends on modulation & SNR</li></ul>`
                },
                {
                    front: "Multiplexing Techniques",
                    back: `<strong>FDM (Frequency Division):</strong> Different frequencies for different channels<ul><li>Non-overlapping bands</li><li>Used in analog TV, radio, OFDM (digital)</li></ul><br><strong>TDM (Time Division):</strong> Different time slots for channels<ul><li>All channels use same frequency, different times</li><li>Used in digital telephony, GSM</li></ul><br><strong>CDMA (Code Division):</strong> Different codes for channels<ul><li>All channels, same frequency, same time</li><li>Used in 3G/4G mobile, GPS</li></ul><br><strong>WDM (Wavelength Division):</strong> Different optical wavelengths (fiber)`
                },
                {
                    front: "Network Protocols - OSI Model Context",
                    back: `<strong>7 Layers:</strong><ol><li>Physical: Wires, signals, modulation</li><li>Data Link: Framing, error correction, MAC</li><li>Network: Routing, IP</li><li>Transport: TCP, UDP</li><li>Session: Conversation management</li><li>Presentation: Data format, encryption</li><li>Application: HTTP, FTP, SMTP</li></ol><br><strong>Communication topics span layers 1-3 mainly</strong>`
                },
                {
                    front: "Wireless Communication Basics",
                    back: `<strong>Propagation Paths:</strong><ul><li>Direct (LOS - Line of Sight)</li><li>Reflected (NLOS - Non-LOS)</li><li>Diffracted (around obstacles)</li><li>Scattered (multiple reflections)</li></ul><br><strong>Fading:</strong> Signal strength variations over time/space<ul><li>Rayleigh fading: NLOS environments</li><li>Rician fading: LOS + NLOS paths</li></ul><br><strong>Path Loss:</strong> Signal weakens with distance<br>Formula: PL = 10n log‚ÇÅ‚ÇÄ(d) + C (n=2 free space, up to 6 urban)`
                },
                {
                    front: "Common Communications Questions",
                    back: `<strong>Q1:</strong> Why use FM in radio instead of AM?<ul><li><strong>Better noise immunity, wider bandwidth acceptable</strong></li></ul><br><strong>Q2:</strong> What's Shannon capacity for 1 MHz, SNR=1000?<ul><li><strong>C = 10‚Å∂ √ó log‚ÇÇ(1001) ‚âà 10 Mbps</strong></li></ul><br><strong>Q3:</strong> Which modulation most efficient: ASK, FSK, PSK?<ul><li><strong>PSK (best noise performance, most efficient)</strong></li></ul>`
                }
            ],
            6: [
                {
                    front: "Embedded System Definition",
                    back: `<strong>Definition:</strong> Computing system with dedicated function, embedded in larger device<br><br><strong>Components:</strong><ul><li>Microcontroller/Processor</li><li>Memory (RAM, ROM, Flash)</li><li>I/O devices (sensors, actuators)</li><li>Power supply</li><li>Communication interface</li></ul><br><strong>vs General-purpose Computer:</strong><ul><li>PC: Multiple general functions, user-programmable</li><li>Embedded: Single dedicated function, pre-programmed</li></ul><br><strong>Examples:</strong> Microwave, car engine control, IoT devices`
                },
                {
                    front: "Real-Time Operating System (RTOS)",
                    back: `<strong>Definition:</strong> OS that processes inputs with guaranteed response time<br><br><strong>Key Features:</strong><ul><li>Deterministic (predictable timing)</li><li>Priority-based scheduling</li><li>Interrupt handling</li><li>Inter-task communication</li></ul><br><strong>Examples:</strong> FreeRTOS, VxWorks, RTOS in Arduino/STM32<br><br><strong>Hard Real-Time:</strong> Deadline violation = failure (medical devices)<br><strong>Soft Real-Time:</strong> Occasional deadline miss acceptable (multimedia)`
                },
                {
                    front: "Task Scheduling & Context Switching",
                    back: `<strong>Task:</strong> Execution unit, has state (ready, running, blocked)<br><strong>Priority:</strong> Higher priority interrupts lower<br><strong>Preemption:</strong> Higher priority can interrupt lower (in preemptive kernel)<br><br><strong>Context Switch:</strong> Save current task state, restore next task<ul><li>Overhead: Saves registers, stack pointer, flags</li><li>Minimized for performance</li></ul><br><strong>Example (FreeRTOS):</strong><br>xTaskCreate(task_function, "name", stack_size, NULL, priority, NULL);`
                },
                {
                    front: "Interrupts in Embedded Systems",
                    back: `<strong>Interrupt:</strong> Asynchronous event that pauses current execution<br><br><strong>Types:</strong><ul><li>External: Pin (button press, sensor trigger)</li><li>Internal: Timer overflow, serial data received</li><li>Software: Trap instruction</li></ul><br><strong>ISR (Interrupt Service Routine):</strong> Code that handles interrupt<ul><li>Should be short & fast</li><li>Avoid printf, long loops in ISR</li></ul><br><strong>Priority:</strong> Higher priority interrupt can interrupt lower`
                },
                {
                    front: "üî• Polling vs Interrupt-Driven I/O",
                    back: `<strong>Polling (Busy-Wait):</strong><br>while(!button_pressed) {<br>    // Do nothing, just wait<br>}<br>execute_function();<br><ul><li>Wastes CPU time</li><li>Simple to implement</li><li>Used for high-frequency events</li></ul><br><strong>Interrupt-Driven:</strong><br>void button_ISR() {<br>    execute_function();<br>}<br>// Main code can do other things<ul><li>Efficient (CPU free when no event)</li><li>More complex</li><li>Essential for real-time systems</li></ul><br><strong>When to Use:</strong><ul><li>Polling: High-frequency, simple events</li><li>Interrupt: Low-frequency, need responsive system</li></ul>`
                },
                {
                    front: "‚≠ê Sensor Interfacing",
                    back: `<strong>ADC (Analog-to-Digital Conversion):</strong> Converts analog to digital<ul><li>Resolution: bits (8-bit, 12-bit, 16-bit, etc.)</li><li>Sampling rate: how many times per second</li><li>Range: voltage from 0 to V_ref</li></ul><br><strong>Example (8051):</strong><br>MOV A, P0 (Read analog value from port)<br>MOV P1, A (Output digital result)<br><br><strong>DAC (Digital-to-Analog):</strong> Opposite conversion<ul><li>Used for audio, voltage output</li></ul><br><strong>Common Sensors:</strong><ul><li>Temperature: LM35, DHT22</li><li>Humidity: DHT22</li><li>Distance: Ultrasonic, IR</li><li>Motion: PIR, accelerometer</li></ul>`
                },
                {
                    front: "‚≠ê Communication Protocols",
                    back: `<strong>UART (Serial):</strong> Point-to-point, simple<ul><li>Baud rate: 9600, 115200, etc.</li><li>Asynchronous</li><li>Error: Only parity bit</li></ul><br><strong>I¬≤C (Inter-Integrated Circuit):</strong> Multi-device on 2 wires<ul><li>Master initiates, slave responds</li><li>Addresses (7-bit), clock speeds (100 kHz, 400 kHz)</li><li>Built-in error checking</li></ul><br><strong>SPI (Serial Peripheral Interface):</strong> Fast, multi-device<ul><li>4 wires: MISO, MOSI, CLK, CS</li><li>Full-duplex</li><li>No addresses (CS selects device)</li></ul><br><strong>CAN Bus:</strong> Automotive, robust<ul><li>Identifier-based</li><li>Error checking & retransmission</li><li>Differential signaling</li></ul>`
                },
                {
                    front: "IoT Communication",
                    back: `<strong>WiFi:</strong> Wireless, high bandwidth<ul><li>Protocol: 802.11 a/b/g/n/ac</li><li>Range: 100 meters</li></ul><br><strong>Bluetooth/BLE:</strong> Short range, low power<ul><li>BLE: Bluetooth Low Energy (~10mA vs 100mA)</li><li>Mesh networking support</li></ul><br><strong>Zigbee:</strong> Low power, mesh networking<ul><li>802.15.4 standard</li><li>Range: 10-100 meters with mesh</li></ul><br><strong>LoRaWAN:</strong> Long range, low power (for IoT)<ul><li>Range: 10+ km (line of sight)</li><li>Very low bandwidth (~50 bps)</li></ul><br><strong>Cellular (LTE, 5G):</strong> Wide coverage, higher cost & power`
                },
                {
                    front: "üî• Power Management",
                    back: `<strong>Sleep Modes:</strong><ul><li>Idle: CPU off, peripherals on (low power)</li><li>Power-down: All off except RTC, watchdog</li><li>Hibernation: CPU & RAM off</li></ul><br><strong>Power Consumption:</strong><ul><li>Active: Highest (¬µW to mW)</li><li>Sleep: Medium</li><li>Hibernation: Lowest (nA level)</li></ul><br><strong>Battery Life:</strong> Hours, days, months, or years depending on use<br><br><strong>Techniques:</strong><ul><li>Dynamic voltage scaling (DVS)</li><li>Clock gating</li><li>Minimize active time</li><li>Use low-power communication</li></ul>`
                },
                {
                    front: "Firmware Update & OTA",
                    back: `<strong>OTA (Over-The-Air):</strong> Update firmware wirelessly<br><br><strong>Steps:</strong><ol><li>Receive new firmware via wireless</li><li>Store in external/secondary memory</li><li>Verify checksum/signature</li><li>Boot into bootloader</li><li>Copy new firmware to main memory</li><li>Reboot</li></ol><br><strong>Considerations:</strong><ul><li>Must preserve bootloader</li><li>Rollback mechanism for failed updates</li><li>Power-fail safe (backup of old firmware)</li></ul>`
                },
                {
                    front: "Hardware-Software Co-design",
                    back: `<strong>Partitioning:</strong> Which functions in hardware vs software?<ul><li>Speed-critical ‚Üí Hardware (gates, FPGA)</li><li>Flexible ‚Üí Software (microcontroller)</li></ul><br><strong>Example:</strong> Crypto<ul><li>AES in hardware: 1000x faster</li><li>AES in software: More flexible</li></ul>`
                },
                {
                    front: "Common Embedded Questions",
                    back: `<strong>Q1:</strong> UART or I¬≤C for multiple sensors?<ul><li><strong>I¬≤C</strong> (multiple devices on 2 wires)</li></ul><br><strong>Q2:</strong> ISR should contain printf?<ul><li><strong>NO</strong> (ISR should be short, printf is slow)</li></ul><br><strong>Q3:</strong> How to measure power in ¬µA range?<ul><li><strong>Current clamp, power meter, multimeter (mA/¬µA range)</strong></li></ul>`
                }
            ],
            7: [
                {
                    front: "üî•üî• Blocking vs Non-Blocking",
                    back: `<strong>Blocking (=):</strong> Sequential execution, immediate update<br><strong>Non-Blocking (<=):</strong> Concurrent evaluation, end-of-timestep update<br><br><strong>GOLDEN RULE:</strong> Use <= for sequential (flip-flops), = for combinational<br><br><strong>SWAP Example - WHY IT MATTERS:</strong><br>// WRONG (blocking):<br>a = b; (a ‚Üê b)<br>c = a; (c ‚Üê NEW a, same as b)<br>// Result: Both a and c are b's value!<br><br>// CORRECT (non-blocking):<br>a <= b; (Schedule: a ‚Üê b)<br>c <= a; (Schedule: c ‚Üê OLD a)<br>// Result: Values swap correctly!`
                },
                {
                    front: "üî• High Impedance (Hi-Z) State",
                    back: `<strong>Definition:</strong> Third state in tri-state logic (besides 0 & 1)<br><br><strong>Characteristics:</strong><ul><li>Output effectively disconnected (open circuit)</li><li>High impedance to ground & supply</li><li>Allows other devices to drive signal</li></ul><br><strong>Symbol:</strong> Z (not 0 or 1)<br><br><strong>Truth Table (Tri-state Buffer):</strong><br>Enable | Input | Output<br>0 | X | Z<br>1 | 0 | 0<br>1 | 1 | 1<br><br><strong>Applications:</strong><ul><li>Bus systems (multiple drivers)</li><li>Memory systems (shared data bus)</li><li>Open-drain outputs</li><li>Multiplexers</li></ul><br><strong>Example:</strong><br>assign output = enable ? data : 1'bz;`
                },
                {
                    front: "üî• Tri-State Bus",
                    back: `<strong>Multiple devices on shared bus:</strong><ul><li>Only ONE device drives at a time (rest in Hi-Z)</li><li>Prevents conflict/short circuit</li><li>Requires pullup/pulldown resistors when no driver</li></ul><br><strong>Memory Access:</strong><ul><li>CPU ‚Üí Memory data bus (8-bit, 16-bit, 32-bit)</li><li>Only accessing device drives, others in Hi-Z</li></ul><br><strong>Open-Drain:</strong> Output can pull to ground OR float (requires pullup)`
                },
                {
                    front: "Three Modeling Levels",
                    back: `<strong>Behavioral:</strong> Describes WHAT (algorithms, high-level)<br><strong>Dataflow:</strong> Describes HOW data flows (combinational logic)<br><strong>Structural:</strong> Describes as gates & modules (gate-level, netlist)<br><br><strong>Hierarchy:</strong> Behavioral (top) ‚Üí Dataflow (middle) ‚Üí Structural (bottom)`
                },
                {
                    front: "üî• Timing Violations - Setup & Hold",
                    back: `<strong>Setup Time (t_su):</strong> Input must be stable BEFORE clock edge<ul><li>Minimum time before clock needed for input to propagate to D input</li></ul><br><strong>Hold Time (t_h):</strong> Input must remain stable AFTER clock edge<ul><li>Minimum time after clock for safe capture</li></ul><br><strong>Timing Violation:</strong><br>Setup: If input changes < t_su before clock ‚Üí metastability<br>Hold: If input changes < t_h after clock ‚Üí metastability<br><br><strong>Metastability:</strong> Output unstable, unpredictable state`
                },
                {
                    front: "Clock Gating - Power Optimization",
                    back: `<strong>Concept:</strong> Gate clock signal when logic not needed<br><br><strong>Benefits:</strong><ul><li>Reduces dynamic power (P = C√óV¬≤√óf)</li><li>Lower clock distribution power</li><li>Reduced heat</li></ul><br><strong>Method:</strong><br>assign gated_clk = clk & enable;<br>// OR: Integrated clock gate cell for proper hold-time handling<br><br><strong>Caution:</strong> Must handle setup/hold time violations`
                },
                {
                    front: "Synthesis & Implementation Steps",
                    back: `<strong>HDL ‚Üí ASIC/FPGA Flow:</strong><ol><li>Synthesis: Verilog/VHDL ‚Üí netlist (logic gates)</li><li>Placement: Place gates on die</li><li>Routing: Connect gates with wires</li><li>Timing Analysis: Check if timing met</li><li>Verification: DFT, power analysis</li><li>Tape-out: Send to fab</li></ol>`
                },
                {
                    front: "Static Timing Analysis (STA)",
                    back: `<strong>Purpose:</strong> Verify circuit meets timing constraints without simulation<br><br><strong>Checks:</strong><ul><li>Setup violations: Data arrives too late</li><li>Hold violations: Data changes too early</li><li>Slack: How much margin before violation</li></ul><br><strong>Timing Paths:</strong><ul><li>Register-to-Register (critical path)</li><li>Input-to-Register</li><li>Register-to-Output</li></ul><br><strong>Slack = Required Time - Arrival Time<br>Negative slack = Timing violation</strong>`
                },
                {
                    front: "Power Analysis in VLSI",
                    back: `<strong>Dynamic Power:</strong> P = C √ó V¬≤ √ó f<br>Power dissipated when transistors switch<br><br><strong>Static (Leakage) Power:</strong> Dissipated even at rest<br><ul><li>CMOS: Leakage ~ 40% of total in modern tech</li><li>Increases exponentially with temperature</li></ul><br><strong>Optimization Techniques:</strong><ul><li>Reduce switching frequency (clock gating)</li><li>Reduce voltage (DVS)</li><li>Reduce capacitance (optimize design)</li><li>Power gating (turn off unused blocks)</li></ul>`
                },
                {
                    front: "DFT (Design for Test)",
                    back: `<strong>Purpose:</strong> Make chip testable after manufacturing<br><br><strong>Techniques:</strong><ul><li>Scan chains: Convert flip-flops to shift registers for testing</li><li>BIST (Built-In Self Test): Self-testing logic</li><li>Boundary scan: JTAG for testing interconnects</li></ul><br><strong>Benefits:</strong><ul><li>Detect manufacturing defects</li><li>Reduce test cost</li><li>Improve chip quality</li></ul>`
                },
                {
                    front: "Verilog Basics",
                    back: `<strong>Module:</strong> Building block of design<br>module name (inputs, outputs);<br>// logic<br>endmodule<br><br><strong>Always Block (Sequential):</strong><br>always @(posedge clk) begin<br>  // Non-blocking assignments<br>  q <= d; // Flip-flop<br>end<br><br><strong>Assign (Combinational):</strong><br>assign y = a & b; // AND gate<br><br><strong>Data Types:</strong><ul><li>wire: Combinational</li><li>reg: Can hold value (not always sequential!)</li><li>integer: For loops</li></ul>`
                },
                {
                    front: "Common VLSI Interview Questions",
                    back: `<strong>Q1:</strong> What's the difference between blocking & non-blocking?<ul><li>Blocking: Sequential, immediate update; Non-blocking: Concurrent, end-of-time update</li></ul><br><strong>Q2:</strong> What causes setup violations?<ul><li><strong>Data arrives too late (> t_su before clock)</strong></li></ul><br><strong>Q3:</strong> How to reduce power?<ul><li><strong>Clock gating, voltage scaling, capacitance reduction</strong></li></ul><br><strong>Q4:</strong> Why use Hi-Z in buses?<ul><li><strong>Allows multiple drivers without short circuits</strong></li></ul>`
                }
            ],
            8: [
                {
                    front: "Binary & Hexadecimal",
                    back: `<strong>Binary (Base 2):</strong> Digits 0, 1<br>10110 = 1√ó16 + 0√ó8 + 1√ó4 + 1√ó2 + 0√ó1 = 22 (decimal)<br><br><strong>Hexadecimal (Base 16):</strong> Digits 0-9, A-F<br>A5 = 10√ó16 + 5√ó1 = 165 (decimal)<br><br><strong>Conversion:</strong><br>Binary to Hex: Group 4 bits<br>1011 0101 = B5<br><br><strong>Binary to Decimal:</strong><br>Sum positional values (powers of 2)`
                },
                {
                    front: "Two's Complement",
                    back: `<strong>Negative Numbers in Binary:</strong><br><strong>Steps to negate:</strong><ol><li>Flip all bits (ones complement)</li><li>Add 1</li></ol><br><strong>Example (-5 in 8-bit):</strong><br>5 = 00000101<br>Flip: 11111010<br>Add 1: 11111011 = -5<br><br><strong>Range (n-bit):</strong> -2^(n-1) to 2^(n-1)-1<br>8-bit: -128 to 127<br><br><strong>Sign Bit:</strong> MSB (0=positive, 1=negative)`
                },
                {
                    front: "Boolean Algebra & Logic Gates",
                    back: `<strong>Basic Gates:</strong><br>AND: A‚Ä¢B (1 only if both 1)<br>OR: A+B (1 if any 1)<br>NOT: ƒÄ (inverts)<br>NAND: NOT AND<br>NOR: NOT OR<br>XOR: ‚äï (1 if different)<br><br><strong>De Morgan's Laws:</strong><br>NOT(A AND B) = NOT A OR NOT B<br>NOT(A OR B) = NOT A AND NOT B<br><br><strong>Boolean Identities:</strong><br>A + 0 = A<br>A √ó 1 = A<br>A + A = A<br>A √ó A = A<br>A + ƒÄ = 1<br>A √ó ƒÄ = 0`
                },
                {
                    front: "K-Map (Karnaugh Map) Minimization",
                    back: `<strong>Purpose:</strong> Minimize Boolean functions graphically<br><br><strong>Steps:</strong><ol><li>Create grid (2^n cells for n variables)</li><li>Place 1s in cells matching truth table</li><li>Group adjacent 1s (powers of 2)</li><li>Write simplified expression</li></ol><br><strong>Example (2-variable):</strong><br>Truth table: AB | Y<br>00 | 0<br>01 | 1<br>10 | 1<br>11 | 1<br><br>K-map groups show: Y = A + B<br><br><strong>Advantages:</strong> Faster than algebra for up to 4-5 variables`
                },
                {
                    front: "Multiplexer & Demultiplexer",
                    back: `<strong>Multiplexer (MUX):</strong> Selects one input<br>Inputs: D0-D(2^n-1)<br>Select: n-bit control<br>Output: Single selected input<br><br><strong>Example (4-to-1 MUX):</strong><br>Y = S1'S0'D0 + S1'S0D1 + S1S0'D2 + S1S0D3<br><br><strong>Demultiplexer (DEMUX):</strong> Distributes one input<br>Outputs: Y0-Y(2^n-1)<br>Select: n-bit control<br>Each output gets input on selected line<br><br><strong>Truth Table (1-to-4 DEMUX):</strong><br>S1 S0 | Y0 Y1 Y2 Y3<br>00 | IN 0  0  0<br>01 | 0  IN 0  0<br>10 | 0  0  IN 0<br>11 | 0  0  0  IN`
                },
                {
                    front: "Encoders & Decoders",
                    back: `<strong>Encoder:</strong> Converts active input to binary code<br>8-to-3 Priority Encoder<br>Inputs: 8 active lines (only one)<br>Output: 3-bit binary representation<br><br><strong>Decoder:</strong> Converts binary code to active output<br>3-to-8 Decoder<br>Inputs: 3-bit binary<br>Outputs: 8 lines (one active)<br><br><strong>Truth Table (3-to-8 Decoder):</strong><br>A2 A1 A0 | Y0 Y1 Y2... Y7<br>000 | 1  0  0... 0<br>001 | 0  1  0... 0<br>010 | 0  0  1... 0<br>111 | 0  0  0... 1`
                },
                {
                    front: "Adders & Subtractors",
                    back: `<strong>Half Adder:</strong> Adds 2 bits<br>Inputs: A, B<br>Outputs: Sum (A XOR B), Carry (A AND B)<br><br><strong>Full Adder:</strong> Adds 2 bits + carry-in<br>Inputs: A, B, Cin<br>Outputs: Sum (A XOR B XOR Cin), Cout<br><br><strong>Ripple Carry Adder:</strong> Chain full adders<br>Slow (carry propagates through each stage)<br><br><strong>Carry Lookahead:</strong> Faster adder<br>Predicts carries using generate/propagate signals<br><br><strong>Subtraction:</strong><br>Using 2's complement: A - B = A + (-B)<br>Invert B, add 1, then add to A`
                },
                {
                    front: "Flip-Flops & Latches",
                    back: `<strong>SR Latch (NOR gates):</strong> Set/Reset<br>S=1, R=0 ‚Üí Q=1 (Set)<br>S=0, R=1 ‚Üí Q=0 (Reset)<br>S=0, R=0 ‚Üí Hold state<br>S=1, R=1 ‚Üí Invalid<br><br><strong>D Flip-Flop (clocked):</strong> Captures D on clock edge<br>Q = D (on rising/falling clock edge)<br>Common in sequential circuits<br><br><strong>JK Flip-Flop:</strong> Versatile<br>J=0, K=0 ‚Üí Hold<br>J=1, K=0 ‚Üí Set (Q=1)<br>J=0, K=1 ‚Üí Reset (Q=0)<br>J=1, K=1 ‚Üí Toggle<br><br><strong>T Flip-Flop:</strong> Toggle<br>T=0 ‚Üí Hold<br>T=1 ‚Üí Toggle Q`
                },
                {
                    front: "Counters & Shift Registers",
                    back: `<strong>Asynchronous Counter (Ripple):</strong><br>Flip-flops cascade, slow<br>Propagation delay increases with bits<br><br><strong>Synchronous Counter:</strong> Faster<br>All flip-flops triggered by same clock<br><br><strong>Shift Register:</strong> Moves data left/right<br>Serial-to-Parallel: Input serial, output parallel<br>Parallel-to-Serial: Opposite<br><br><strong>Ring Counter:</strong> Circular shift<br>Single 1 rotates through stages<br><br><strong>Johnson Counter:</strong> Twisted ring<br>Complemented output fed back`
                },
                {
                    front: "Combinational vs Sequential",
                    back: `<strong>Combinational:</strong><br>Output depends ONLY on current inputs<br>No memory, no feedback<br>Examples: Adders, multiplexers, decoders<br>Truth table fully defines behavior<br><br><strong>Sequential:</strong><br>Output depends on current inputs AND past state<br>Has memory (flip-flops)<br>Examples: Counters, shift registers, FSMs<br>Clocked (synchronous) or asynchronous<br><br><strong>State Diagram:</strong> Shows state transitions<br>Mealy Machine: Output depends on input & state<br>Moore Machine: Output depends only on state`
                },
                {
                    front: "Number Systems & Codes",
                    back: `<strong>BCD (Binary Coded Decimal):</strong><br>Each digit 0-9 represented as 4-bit binary<br>5 = 0101, 19 = 0001 1001<br>Used in digital displays<br><br><strong>Gray Code:</strong><br>Adjacent codes differ by 1 bit<br>Reduces errors in digital systems<br>Binary: 00,01,10,11<br>Gray: 00,01,11,10<br><br><strong>Parity Code:</strong><br>Even parity: Total 1s = even<br>Odd parity: Total 1s = odd<br>Error detection (1-bit errors)<br><br><strong>Hamming Code:</strong><br>Error correction (detects & corrects 1-bit errors)<br>Uses parity bits in specific positions`
                },
                {
                    front: "Timing Concepts",
                    back: `<strong>Propagation Delay:</strong> Time for signal to travel through gate<br>tpd (typical 1-3 ns for modern logic)<br><br><strong>Setup Time:</strong> Data must be stable before clock<br><br><strong>Hold Time:</strong> Data must remain stable after clock<br><br><strong>Clock-to-Output:</strong> Delay from clock to output valid<br><br><strong>Critical Path:</strong> Longest delay path in circuit<br>Determines maximum clock frequency<br>f_max = 1 / (critical path + setup time)`
                },
                {
                    front: "Common Digital Electronics Questions",
                    back: `<strong>Q1:</strong> Difference between combinational & sequential?<ul><li>Combinational: No memory, output = f(inputs)</li><li>Sequential: Has memory, output = f(inputs, state)</li></ul><br><strong>Q2:</strong> What's 2's complement of -5?<ul><li>5 in binary: 00000101</li><li>Invert: 11111010</li><li>Add 1: 11111011</li></ul><br><strong>Q3:</strong> How many outputs in 3-to-8 decoder?<ul><li><strong>8 outputs (2^3)</strong></li></ul><br><strong>Q4:</strong> Why use Gray code?<ul><li><strong>Adjacent codes differ by 1 bit (reduces errors)</strong></li></ul>`
                }
            ]
        };

        let currentTopic = 1;

        // Initialize flashcards
        function initFlashcards() {
            updateTopicView(1);
            setupEventListeners();
        }

        function setupEventListeners() {
            document.querySelectorAll('.topic-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    document.querySelectorAll('.topic-btn').forEach(b => b.classList.remove('active'));
                    this.classList.add('active');
                    const topic = this.getAttribute('data-topic');
                    currentTopic = topic;
                    updateTopicView(topic);
                });
            });
        }

        function updateTopicView(topic) {
            const container = document.getElementById('flashcardsContainer');
            const topicNames = {
                1: 'üìå TOPIC 1: MICROPROCESSOR (8086)',
                2: 'üìå TOPIC 2: MICROCONTROLLER (8051)',
                3: 'üìå TOPIC 3: CIRCUITS & NETWORKS',
                4: 'üìå TOPIC 4: DIGITAL SIGNAL PROCESSING (DSP)',
                5: 'üìå TOPIC 5: ANALOG & DIGITAL COMMUNICATIONS',
                6: 'üìå TOPIC 6: EMBEDDED SYSTEMS & IoT',
                7: 'üìå TOPIC 7: VLSI & DESIGN',
                8: 'üìå TOPIC 8: DIGITAL ELECTRONICS'
            };

            const topicDescriptions = {
                1: '15 Cards | 8086 Architecture, Instructions, Registers, Stack Operations & More',
                2: '15 Cards | 8051 Memory, I/O, Instructions, Timers, Serial Communication & More',
                3: '15 Cards | Thevenin/Norton, Power Transfer, AC Circuits, Resonance & More',
                4: '12 Cards | Sampling, Aliasing, Fourier Transform, Digital Filters & More',
                5: '12 Cards | Modulation, Channel Capacity, Error Coding, Multiplexing & More',
                6: '12 Cards | Real-Time OS, Task Scheduling, Sensors, Communication Protocols & More',
                7: '15 Cards | Blocking/Non-Blocking, Timing, Power, DFT, Verilog & More',
                8: '15 Cards | Number Systems, Logic Gates, Adders, Flip-Flops, Counters & More'
            };

            let topicHeader = `<div class="topic-header active">
                <h2>${topicNames[topic]}</h2>
                <p>${topicDescriptions[topic]}</p>
            </div>`;

            let cardsHTML = '<div class="flashcards-grid">';
            flashcardsData[topic].forEach((card, index) => {
                cardsHTML += `
                    <div class="flashcard topic${topic}" onclick="this.classList.toggle('flipped')">
                        <div class="flashcard-inner">
                            <div class="flashcard-front">
                                <div class="flashcard-front-top">
                                    <div class="flashcard-front-title">Card ${index + 1}</div>
                                    <div class="flashcard-front-number">Topic ${topic}</div>
                                </div>
                                <div class="flashcard-front-content">${card.front}</div>
                                <div class="flashcard-front-hint">Click to reveal answer</div>
                            </div>
                            <div class="flashcard-back">
                                <h3>${card.front}</h3>
                                ${card.back}
                            </div>
                        </div>
                    </div>
                `;
            });
            cardsHTML += '</div>';

            container.innerHTML = topicHeader + cardsHTML;
            updateProgress();
        }

        function updateProgress() {
            const totalCards = Object.values(flashcardsData).reduce((sum, topic) => sum + topic.length, 0);
            document.getElementById('progressText').textContent = `üìö Total: ${totalCards}+ flashcards | Topic ${currentTopic}: 15 cards`;
        }

        function shuffleCards() {
            const cards = document.querySelectorAll('.flashcard');
            const cardsArray = Array.from(cards);
            for (let i = cardsArray.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                cardsArray[i].parentNode.insertBefore(cardsArray[j], cardsArray[i]);
            }
        }

        function downloadHTML() {
            const htmlContent = document.documentElement.outerHTML;
            const blob = new Blob([htmlContent], { type: 'text/html' });
            const url = window.URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = 'Placement_Exam_Flashcards_120+.html';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            window.URL.revokeObjectURL(url);
            alert('‚úÖ Flashcards downloaded successfully!');
        }

        // Keyboard navigation
        document.addEventListener('keydown', function(event) {
            if (event.key === 'ArrowRight') {
                const nextBtn = document.querySelector('.topic-btn.active')?.nextElementSibling;
                if (nextBtn?.classList.contains('topic-btn')) nextBtn.click();
            } else if (event.key === 'ArrowLeft') {
                const prevBtn = document.querySelector('.topic-btn.active')?.previousElementSibling;
                if (prevBtn?.classList.contains('topic-btn')) prevBtn.click();
            }
        });

        initFlashcards();
    </script>
</body>
</html>
